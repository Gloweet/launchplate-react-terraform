name: AWS multi-env deployment

permissions:
  # Allows the workflow to request an OIDC token
  id-token: write

  # Required for actions/checkout
  contents: read

  # Required for issue/PR comments
  issues: write
  pull-requests: write

on:
  # checkov:skip=CKV_GHA_7 reason="Environment selection is safe and intentional"
  workflow_dispatch:
    inputs:
      environment:
        description: "Select the environment to deploy to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - stg
          - prod
      auto_apply:
        description: "Apply Terraform changes automatically"
        required: false
        default: false
        type: boolean
  push:
    branches:
      - "main"
      - "staging"
      - "development"
      - "release/*"
      - "feature/*"
      - "bugfix/*"
  pull_request:
    branches:
      - "main"
      - "staging"
      - "development"
      - "release/*"
      - "feature/*"
      - "bugfix/*"
    types: [opened, synchronize, reopened]
  issue_comment:
    types: [created]
env:
  aws_region: eu-west-3
  tf_version: "1.12.1"
  working_dir_tf: "terraform/live"
  working_dir_web: "web"
  tf_plugin_cache_dir: ${{ github.workspace }}/.terraform.d/plugin-cache
  terraform_approvers: '["terraform-approvers"]'
  auto_apply: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true') || (github.event_name == 'push' && (github.ref == 'refs/heads/development' || github.ref == 'refs/heads/staging')) }}

  # verbosity setting for Terraform logs
  TF_LOG: INFO

jobs:
  dump:
    name: Dump
    runs-on: ubuntu-latest
    steps:
      - name: Dump GitHub context
        run: echo "${{ toJSON(github) }}"

  compute_env:
    name: Compute Environment
    runs-on: ubuntu-latest
    outputs:
      # Target environment (default: dev)
      environment: ${{ steps.set-env.outputs.environment }}
      # Auto apply terraform (default: false)
      tf_apply: ${{ steps.set-env.outputs.tf_apply }}
      # True if the target environment is valid doesn't fallback to default
      branch_filter_valid: ${{ steps.set-env.outputs.branch_filter_valid }}
    steps:
      - id: set-env
        run: |
          # Default values
          ENVIRONMENT="dev"
          TF_APPLY="false"
          BRANCH_FILTER_VALID="false"

          EVENT_NAME="${{ github.event_name }}"
          REF_NAME="${{ github.ref_name }}"
          COMMENT_BODY="${{ github.event.comment.body }}"
          EVENT_INPUT_ENV="${{ github.event.inputs.environment }}"
          EVENT_INPUT_APPLY="${{ github.event.inputs.tf_apply }}"
          PR_BASE_REF="${{ github.event.pull_request.base.ref }}"

          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            ENVIRONMENT="$EVENT_INPUT_ENV"
            BRANCH_FILTER_VALID="true"
            if [[ "$EVENT_INPUT_APPLY" == "true" ]]; then
              TF_APPLY="true"
            fi

          elif [[ "$EVENT_NAME" == "issue_comment" ]]; then
            if [[ "$REF_NAME" == "main" ]]; then
              ENVIRONMENT="prod"
              BRANCH_FILTER_VALID="true"
            elif [[ "$REF_NAME" == "staging" ]]; then
              ENVIRONMENT="stg"
              BRANCH_FILTER_VALID="true"
            elif [[ "$REF_NAME" == "development" ]]; then
              ENVIRONMENT="dev"
              BRANCH_FILTER_VALID="true"
            fi

            if [[ "$BRANCH_FILTER_VALID" == "true" && "$COMMENT_BODY" == "apply" ]]; then
              TF_APPLY="true"
            fi

          elif [[ "$EVENT_NAME" == "pull_request" ]]; then
            if [[ "$PR_BASE_REF" == "main" ]]; then
              ENVIRONMENT="prod"
              BRANCH_FILTER_VALID="true"
            elif [[ "$PR_BASE_REF" == "staging" ]]; then
              ENVIRONMENT="stg"
              BRANCH_FILTER_VALID="true"
            elif [[ "$PR_BASE_REF" == "development" ]]; then
              ENVIRONMENT="dev"
              BRANCH_FILTER_VALID="true"
            fi

          elif [[ "$EVENT_NAME" == "push" ]]; then
            if [[ "$REF_NAME" == "main" ]]; then
              ENVIRONMENT="prod"
              BRANCH_FILTER_VALID="true"
            elif [[ "$REF_NAME" == "staging" ]]; then
              ENVIRONMENT="stg"
              BRANCH_FILTER_VALID="true"
            elif [[ "$REF_NAME" == "development" ]]; then
              ENVIRONMENT="dev"
              BRANCH_FILTER_VALID="true"
            fi
          fi

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "tf_apply=$TF_APPLY" >> $GITHUB_OUTPUT
          echo "branch_filter_valid=$BRANCH_FILTER_VALID" >> $GITHUB_OUTPUT

  detect_changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    needs: [compute_env]
    outputs:
      environment: ${{ needs.compute_env.outputs.environment }}
      run_tf: ${{ steps.set-job-conditions.outputs.run_tf }}
      run_web: ${{ steps.set-job-conditions.outputs.run_web }}
      deploy_tf: ${{ steps.set-job-conditions.outputs.deploy_tf }}
      deploy_web: ${{ steps.set-job-conditions.outputs.deploy_web }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            terraform:
              - 'terraform/**/*.tf'
            web:
              - 'web/**'

      - name: set-job-conditions
        run: |
          RUN_TF=${{github.event_name == 'workflow_dispatch' || steps.filter.outputs.terraform == 'true'}}
          DEPLOY_TF=$(RUN_TF && ${{needs.compute_env.tf_apply == 'true'}})

          RUN_WEB=${{ steps.filter.outputs.web == true }}
          DEPLOY_WEB=$(RUN_WEB && ${{needs.compute_env.branch_filter_valid == 'true'}})

          echo "run_tf=$RUN_TF" >> $GITHUB_OUTPUT
          echo "run_web=$RUN_WEB" >> $GITHUB_OUTPUT
          echo "deploy_tf=$DEPLOY_TF" >> $GITHUB_OUTPUT
          echo "deploy_web=$DEPLOY_WEB" >> $GITHUB_OUTPUT

  tf_checks:
    name: TF Checks
    runs-on: ubuntu-latest
    needs: [detect_changes]
    if: needs.detect_changes.outputs.run_tf == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Terraform Format Check
        run: |
          cd ${{ env.working_dir_tf }}
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace (defaults to 'prod')
        run: |
          cd ${{ env.working_dir_tf }}
          terraform workspace select '${{ needs.detect_changes.outputs.environment }}' || terraform workspace new '${{ needs.detect_changes.outputs.environment }}'

      - uses: actions/setup-python@v3
      - name: Run pre-commit hooks in terraform directory
        uses: pre-commit/action@v3.0.1
        with:
          working-directory: ${{ env.working_dir_tf }}
      - name: Upload pre-commit reports
        uses: actions/upload-artifact@v4
        with:
          name: pre-commit-report
          path: terraform/pre-commit-report
          retention-days: 1

  web_build:
    name: Web Build
    runs-on: ubuntu-latest
    needs: [detect_changes]
    if: needs.detect_changes.outputs.run_web == 'true'
    outputs:
      app_version: ${{ steps.get_version.outputs.app_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        name: Install pnpm
        with:
          version: 9
          run_install: false

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "pnpm"

      - name: Install dependencies
        run: |
          cd ${{ env.working_dir_web }}
          pnpm install

      - name: Run Vitest tests
        run: |
          cd ${{ env.working_dir_web }}
          pnpm test
        continue-on-error: true
        env:
          CI: true

      - name: Get App version
        id: get_version
        run: |
          cd ${{ env.working_dir_web }}
          APP_VERSION=$(node -p "require('./package.json').version")
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "App Version: $APP_VERSION"

      - name: Build project (defaults to prod config)
        run: cd ${{ env.working_dir_web }} && npm run build:${{ needs.detect_changes.outputs.environment }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: ${{ env.working_dir_web }}/dist
          retention-days: 1

  tf_plan:
    name: TF Plan
    needs: [detect_changes, tf_checks]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        run: |
          cd ${{ env.working_dir_tf }}
          terraform workspace select '${{ needs.detect_changes.outputs.environment }}' || terraform workspace new '${{ needs.detect_changes.outputs.environment }}'

      - name: Terraform Plan
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          cd ${{ env.working_dir_tf }}
          terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.detect_changes.outputs.environment }}
          path: ${{ env.working_dir_tf }}/tfplan
          retention-days: 5

      - name: Generate Terraform Plan Output for PR
        if: github.event_name == 'pull_request'
        run: |
          cd ${{ env.working_dir_tf }}
          terraform show -no-color tfplan > plan_output.txt
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
          cat plan_output.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create Plan Summary Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const teams = JSON.parse(process.env.TERRAFORM_APPROVERS)
            const teamNames = teams.map(team => `@${team.name}`).join(', ');
            const planOutput = process.env.PLAN_OUTPUT || '';
            let planSummary = "Plan: unknown";
            if (planOutput) {
              const match = planOutput.match(/(Plan:.*|No changes.*)/);
              if (match) planSummary = match[0];
            }

            const body = `### Terraform Plan Created
            **Plan Summary:** ${planSummary}

            <details>
            <summary>Click to view the full Terraform plan</summary>

            \`\`\`terraform
            ${planOutput}
            \`\`\`
            </details>

            Please review the plan and comment:
            - \`/apply\` to apply these changes (only members of the \`${teamNames}\` team(s) can approve)

            **Notes:** Only members of the \`${teamNames}\` team(s) can approve and trigger the apply.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      # When manual approval is required (on workflow_dispatch and push):
      # Create an annotation to notify the user on the TF plan and how to apply it
      - name: Generate Terraform Plan Output
        if: needs.compute_env.outputs.auto_apply == 'false'
        run: |
          cd ${{ env.working_dir_tf }}
          terraform show -no-color tfplan > plan_output.txt
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
          cat plan_output.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create Workflow Run Annotation for Manual Approval
        if: needs.compute_env.outputs.auto_apply == 'false'
        run: |
          # Create a summary of the plan using a more reliable method
          PLAN_SUMMARY=$(echo "$PLAN_OUTPUT" | grep -E 'Plan:|No changes' || echo "Plan: unknown")
          # Handle empty plan output
          if [ -z "$PLAN_OUTPUT" ]; then
            PLAN_SUMMARY="Plan: unknown (empty plan output)"
          fi

          # Create the annotation with plan details
          echo "::notice title=Manual Approval Required::Terraform plan created for environment '${{ needs.detect_changes.outputs.environment }}'. Plan summary: $PLAN_SUMMARY. To apply, run this workflow again with auto_apply=true."

          # Write full plan to step summary
          echo "## Terraform Plan for environment: ${{ needs.detect_changes.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "To apply this plan, run the workflow again with auto_apply=true" >> $GITHUB_STEP_SUMMARY
          echo '```terraform' >> $GITHUB_STEP_SUMMARY
          echo "$PLAN_OUTPUT" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          echo "MANUAL_APPROVAL_NEEDED=true" >> $GITHUB_ENV
        env:
          ENVIRONMENT: ${{ needs.detect_changes.outputs.environment }}
          PLAN_OUTPUT: ${{ env.PLAN_OUTPUT }}

  tf_apply:
    name: TF Apply
    runs-on: ubuntu-latest
    needs: [detect_changes, tf_plan]
    if: needs.detect_changes.outputs.deploy_tf == 'true'

    steps:
      - name: Check commenter team membership
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const environment = needs.detect_changes.outputs.environment
            const commenter = context.payload.comment.user.login
            const teams = JSON.parse(process.env.TERRAFORM_APPROVERS)
            let isApproved = false

            try {
              // For pull request comments only
              for (const team of teams) {
                try {
                  const { data: teamMembership } = await github.rest.teams.getMembershipForUserInOrg({
                    org: context.repo.owner,
                    team_slug: team,
                    username: commenter
                  });

                  if (teamMembership.state === 'active') {
                    isApproved = true;
                    await github.rest.issues.createComment({
                      issue_number: context.issue.number,
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      body: `✅ Terraform apply approved by @${commenter} (member of ${team}) for environment: ${environment}`
                    });
                    break;
                  }
                } catch (err) {
                  // User is not in this team, continue checking other teams
                  console.log(`User ${commenter} is not in team ${team}: ${err.message}`);
                }
              }

              if (!isApproved) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `❌ @${commenter} is not authorized to approve Terraform apply. Must be a member of: ${teams.join(', ')}`
                });
                core.setFailed('Commenter is not in an approved team');
              }
            } catch (error) {
              console.error('Error checking team membership:', error);
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `❌ Error checking team membership: ${error.message}`
              });
              core.setFailed(`Error checking team membership: ${error.message}`);
            }
        env:
          TERRAFORM_APPROVERS: ${{ env.terraform_approvers }}
          ENVIRONMENT: ${{ needs.detect_changes.outputs.environment }}

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ needs.detect_changes.outputs.environment }}
          path: ${{ env.working_dir_tf }}
          fail-on-error: true

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        run: |
          cd ${{ env.working_dir_tf }}
          echo "Using environment: ${{ needs.detect_changes.outputs.environment }}"
          terraform workspace select '${{ needs.detect_changes.outputs.environment }}' || terraform workspace new '${{ needs.detect_changes.outputs.environment }}'

      - name: Terraform Apply
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          cd ${{ env.working_dir_tf }}
          terraform apply -auto-approve tfplan

  terraform_dependency:
    name: Terraform Dependency Check
    needs: [detect_changes]
    if: needs.detect_changes.outputs.deploy_tf == 'true'
    runs-on: ubuntu-latest
    steps:
      - run: echo "This job exists to create a dependency for s3_sync when terraform changes are detected"

  # tf_apply_auto job removed and consolidated with tf_apply

  s3_sync:
    name: Web Sync to S3
    needs:
      [web_build, compute_env, detect_changes, terraform_dependency, tf_apply]
    if: |
      needs.detect_changes.outputs.deploy_web == 'true' &&
      (needs.tf_apply.result == 'success' || needs.tf_apply.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: web-dist
          path: web/dist

      - name: Sync to S3 Release environment
        run: |
          aws s3 sync web/dist s3://${{ needs.detect_changes.outputs.environment }}-launchplate-react-primary && \
          aws s3 sync web/dist s3://${{ needs.detect_changes.outputs.environment }}-launchplate-react-failover

      - name: Sync to S3 Pre-release environment
        run: |
          aws s3 sync web/dist s3://${{ needs.detect_changes.outputs.environment }}-launchplate-react-primary

      - name: Get CloudFront Distribution ID from Terraform
        working-directory: terraform/live
        run: |
          terraform workspace select ${{ needs.detect_changes.outputs.environment }}
          echo "CLOUDFRONT_ID=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_ENV

      - name: Invalidate CloudFront cache
        run: |
          echo "Invalidating CloudFront distribution ID: $CLOUDFRONT_ID"
          aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_ID --paths '/*' || echo "⚠️ Cache invalidation failed, continuing anyway."

  slack:
    name: Slack
    needs: [detect_changes, s3_sync, tf_apply]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - uses: technote-space/workflow-conclusion-action@v3

      - uses: 8398a7/action-slack@v3
        if: env.WORKFLOW_CONCLUSION != 'skipped' && env.WORKFLOW_CONCLUSION != 'cancelled'
        with:
          status: custom
          fields: workflow,job,commit,repo,ref,author,took
          custom_payload: |
            {
              attachments: [{
                color: '${{ env.WORKFLOW_CONCLUSION }}' === 'success' ? 'good' : '${{ env.WORKFLOW_CONCLUSION }}' === 'failure' ? 'danger' : 'warning',
                text: `${process.env.AS_WORKFLOW}\n${process.env.AS_JOB} (${process.env.AS_COMMIT}) of ${process.env.AS_REPO}@${process.env.AS_REF} by ${process.env.AS_AUTHOR} *${{ env.WORKFLOW_CONCLUSION }}* in ${process.env.AS_TOOK}

                *Environment:* ${{ needs.detect_changes.outputs.environment }}
                *Terraform Deployed:* ${{ needs.detect_changes.outputs.tf_deploy }}
                *S3 Synced:* ${{ needs.detect_changes.outputs.web_deploy }}`
              }]
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
