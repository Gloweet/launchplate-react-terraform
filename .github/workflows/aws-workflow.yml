name: AWS multi-env deployment

permissions:
  # Allows the workflow to request an OIDC token
  id-token: write

  # Required for actions/checkout
  contents: read

on:
  # checkov:skip=CKV_GHA_7 reason="Environment selection is safe and intentional"
  workflow_dispatch:
    inputs:
      environment:
        description: "Select the environment to deploy to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - stg
          - prod
      auto_apply:
        description: "Apply Terraform changes automatically"
        required: false
        default: false
        type: boolean
  push:
    branches:
      - "main"
      - "staging"
      - "development"
      - "release/*"
      - "feature/*"
      - "bugfix/*"
  pull_request:
    branches:
      - "main"
      - "staging"
      - "development"
      - "release/*"
      - "feature/*"
      - "bugfix/*"
  issue_comment:
    types: [created]

env:
  aws_region: eu-west-3
  environment: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || (github.ref_name == 'main' && 'prod' || github.ref_name == 'staging' && 'stg' || github.ref_name == 'development' && 'dev') }}
  tf_version: "1.12.1"
  working_dir_tf: "terraform/live"
  working_dir_web: "web"
  tf_plugin_cache_dir: ${{ github.workspace }}/.terraform.d/plugin-cache
  terraform_approvers: '["terraform-approvers"]'
  auto_apply: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true' || github.event_name == 'push' && (github.ref == 'refs/heads/development' || github.ref == 'refs/heads/staging') }}

  # verbosity setting for Terraform logs
  TF_LOG: INFO

jobs:
  detect_changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      terraform_changes: ${{ steps.filter.outputs.terraform }}
      web_changes: ${{ steps.filter.outputs.web }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            terraform:
              - 'terraform/**'
            web:
              - 'web/**'

  tf_checks:
    name: TF Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || needs.detect_changes.outputs.terraform_changes == 'true'
    needs: detect_changes

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Terraform Format Check
        run: |
          cd ${{ env.working_dir_tf }}
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        run: |
          cd ${{ env.working_dir_tf }}
          terraform workspace select ${{ env.environment }} || terraform workspace new ${{ env.environment }}

      - name: Terraform Validate
        run: |
          cd ${{ env.working_dir_tf }}
          terraform validate

  web_build:
    name: Web Lint, Test & Build
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || needs.detect_changes.outputs.web_changes == 'true'
    needs: [detect_changes]
    outputs:
      app_version: ${{ steps.get_version.outputs.app_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        name: Install pnpm
        with:
          version: 9
          run_install: false

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: "pnpm"

      - name: Install dependencies
        run: |
          cd ${{ env.working_dir_web }}
          pnpm install

      - name: Run Vitest tests
        run: |
          cd ${{ env.working_dir_web }}
          pnpm test
        continue-on-error: true
        env:
          CI: true

      - name: Get App version
        id: get_version
        run: |
          cd ${{ env.working_dir_web }}
          APP_VERSION=$(node -p "require('./package.json').version")
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "App Version: $APP_VERSION"

      - name: Build project
        run: cd ${{ env.working_dir_web }} && npm run build:${{ env.environment }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: ${{ env.working_dir_web }}/dist
          retention-days: 1

  tf_plan:
    name: TF Plan
    needs: [tf_checks]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        run: |
          cd ${{ env.working_dir_tf }}
          terraform workspace select ${{ env.environment }} || terraform workspace new ${{ env.environment }}

      - name: Terraform Plan
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          cd ${{ env.working_dir_tf }}
          terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ env.environment }}
          path: ${{ env.working_dir_tf }}/tfplan
          retention-days: 5

      - name: Create Plan Summary Comment
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'false')
        uses: actions/github-script@v6
        with:
          script: |
            let body = '### Terraform Plan Created\n\n';

            if (github.event_name == 'pull_request') {
              body += 'Please review the plan and comment `/apply` to apply these changes.\n\n**Note:** Only members of the `terraform-approvers` team can approve and trigger the apply.';

              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            } else {
              // For workflow_dispatch, create an issue
              const title = `Terraform Plan for ${process.env.ENVIRONMENT} - Approval Needed`;
              body += `Environment: ${process.env.ENVIRONMENT}\n\nPlease review the plan and comment \`/apply\` to apply these changes.\n\n**Note:** Only members of the \`terraform-approvers\` team can approve and trigger the apply.`;

              const { data: issue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['terraform', 'approval-needed', `env:${process.env.ENVIRONMENT}`]
              });

              // Save issue number to environment for later use
              core.exportVariable('APPROVAL_ISSUE_NUMBER', issue.number);
              console.log(`Created approval issue #${issue.number}`);
            }
        env:
          ENVIRONMENT: ${{ env.environment }}

  tf_apply:
    name: TF Apply
    runs-on: ubuntu-latest
    needs: [tf_plan]
    if: |
      (github.event_name == 'issue_comment' && github.event.comment.body == '/apply') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.auto_apply == 'true') ||
      (github.event_name == 'push' && (github.ref == 'refs/heads/development' || github.ref == 'refs/heads/staging'))

    steps:
      - name: Check commenter team membership
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v6
        with:
          script: |
            const commenter = context.payload.comment.user.login
            const teams = JSON.parse(process.env.TERRAFORM_APPROVERS)
            let isApproved = false

            try {
              // Check if this is a PR comment or an issue comment (from workflow_dispatch approval)
              const isPR = !!context.payload.issue.pull_request

              // Get environment from issue labels if it's not a PR
              let environment = process.env.ENVIRONMENT
              if (!isPR) {
                const { data: issue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number
                })

                const envLabel = issue.labels.find(label => label.name.startsWith('env:'))
                if (envLabel) {
                  environment = envLabel.name.replace('env:', '')
                  console.log(`Using environment from issue label: ${environment}`)
                  core.exportVariable('ENVIRONMENT', environment)
                }
              }

              for (const team of teams) {
                const { data: members } = await github.rest.teams.listMembersInOrg({
                  org: context.repo.owner,
                  team_slug: team
                })

                if (members.some(member => member.login === commenter)) {
                  isApproved = true
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: `✅ Terraform apply approved by @${commenter} (member of ${team}) for environment: ${environment}`
                  })
                  break
                }
              }

              if (!isApproved) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `❌ @${commenter} is not authorized to approve Terraform apply. Must be a member of: ${teams.join(', ')}`
                })
                core.setFailed('Commenter is not in an approved team')
              }
            } catch (error) {
              console.error('Error checking team membership:', error)
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `❌ Error checking team membership: ${error.message}`
              })
              core.setFailed(`Error checking team membership: ${error.message}`)
            }
        env:
          TERRAFORM_APPROVERS: ${{ env.terraform_approvers }}
          ENVIRONMENT: ${{ env.environment }}

      - name: Set environment from issue
        if: github.event_name == 'issue_comment' && !github.event.issue.pull_request
        uses: actions/github-script@v6
        with:
          script: |
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            })

            const envLabel = issue.labels.find(label => label.name.startsWith('env:'))
            if (envLabel) {
              const environment = envLabel.name.replace('env:', '')
              core.exportVariable('WORKFLOW_ENVIRONMENT', environment)
              console.log(`Setting environment from issue label: ${environment}`)
            } else {
              core.setFailed('Could not determine environment from issue labels')
            }

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS & Terraform Cache
        uses: ./.github/actions/setup-aws-tf-cache
        with:
          aws-role-arn: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}
          cache-path: ${{ env.tf_plugin_cache_dir }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.tf_version }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ github.event_name == 'issue_comment' && !github.event.issue.pull_request && env.WORKFLOW_ENVIRONMENT || env.environment }}
          path: ${{ env.working_dir_tf }}
          fail-on-error: true

      - name: Terraform Init
        run: |
          cd ${{ env.working_dir_tf }}
          terraform init

      - name: Terraform Workspace
        run: |
          cd ${{ env.working_dir_tf }}
          DEPLOY_ENV="${{ github.event_name == 'issue_comment' && !github.event.issue.pull_request && env.WORKFLOW_ENVIRONMENT || env.environment }}"
          echo "Using environment: $DEPLOY_ENV"
          terraform workspace select $DEPLOY_ENV || terraform workspace new $DEPLOY_ENV

      - name: Terraform Apply
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          cd ${{ env.working_dir_tf }}
          terraform apply -auto-approve tfplan

  terraform_dependency:
    name: Terraform Dependency Check
    needs: [detect_changes]
    if: needs.detect_changes.outputs.terraform_changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - run: echo "This job exists to create a dependency for s3_sync when terraform changes are detected"

  # tf_apply_auto job removed and consolidated with tf_apply

  s3_sync:
    name: Web Sync to S3
    needs: [web_build, detect_changes, terraform_dependency, tf_apply]
    if: |
      (github.event_name == 'workflow_dispatch' || needs.detect_changes.outputs.web_changes == 'true') &&
      (needs.tf_apply.result == 'success' || needs.tf_apply.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.aws_region }}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: web-dist
          path: web/dist

      - name: Sync to S3 Release environment
        if: env.environment == 'prod'
        run: |
          aws s3 sync web/dist s3://${{ env.environment }}-launchplate-react-primary && \
          aws s3 sync web/dist s3://${{ env.environment }}-launchplate-react-failover

      - name: Sync to S3 Pre-release environment
        if: env.environment != 'prod'
        run: |
          aws s3 sync web/dist s3://${{ env.environment }}-launchplate-react-primary

      - name: Get CloudFront Distribution ID from Terraform
        working-directory: terraform/live
        run: |
          terraform workspace select ${{ env.environment }}
          echo "CLOUDFRONT_ID=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_ENV

      - name: Invalidate CloudFront cache
        run: |
          echo "Invalidating CloudFront distribution ID: $CLOUDFRONT_ID"
          aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_ID --paths '/*' || echo "⚠️ Cache invalidation failed, continuing anyway."

  slack:
    name: Slack
    needs: [s3_sync, tf_apply]
    if: always()
    runs-on: ubuntu-latest

    steps:
      # run this action to get the workflow conclusion
      - uses: technote-space/workflow-conclusion-action@v3

      # run other action with the workflow conclusion
      - uses: 8398a7/action-slack@v3
        # Prevents posting useless messages for skipped or cancelled workflows.
        if: env.WORKFLOW_CONCLUSION != 'skipped' && env.WORKFLOW_CONCLUSION != 'cancelled'

        with:
          status: custom
          fields: workflow,job,commit,repo,ref,author,took
          custom_payload: |
            {
              attachments: [{
                color: '${{ env.WORKFLOW_CONCLUSION }}' === 'success' ? 'good' : '${{ env.WORKFLOW_CONCLUSION }}' === 'failure' ? 'danger' : 'warning',
                text: `${process.env.AS_WORKFLOW}\n${process.env.AS_JOB} (${process.env.AS_COMMIT}) of ${process.env.AS_REPO}@${process.env.AS_REF} by ${process.env.AS_AUTHOR} ${{ env.WORKFLOW_CONCLUSION }} in ${process.env.AS_TOOK}`,
              }]
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
